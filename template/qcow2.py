import random
import math
from collections import OrderedDict

class Value:
    def __init__(self, data):
        self.data = data

    def __call__(self):
        return self.data


class Ref:
    def __init__(self, path):
        self.path = path
    #TODO: Functionalize it!
    def __call__(self, struct):
        return reduce(lambda x, y: x[y], self.path, struct)

# Offsets

def follow(path):
    def result(struct):
        return Ref(path)(struct)['offset'] + Ref(path)(struct)['size']
    return result

def value(path):
    def result(struct):
        return Ref(path)(struct).value
    return result

def fixed(val):
    def result(struct):
        return val
    return result

def free(path):
    pass


class Generators(object):
    @staticmethod
    def cluster_size(struct):
        return  2**struct['header']['cluster_bits']['value']

    @staticmethod
    def magic(struct):
        return "QFI\xfb"

    @staticmethod
    def version(struct, seed=None):
        random.seed(seed)
        return random.choice([2, 3])

    @staticmethod
    def backing_file_offset(struct, seed=None):
        """Until COW, that needs manipulation with several files, is not
        implemented
        """
        return 0

    @staticmethod
    def backing_file_size(struct, seed=None):
        """Until COW, that needs manipulation with several files, is not
        implemented
        """
        return 0

    @staticmethod
    def cluster_bits(struct, seed=None):
        random.seed(seed)
        return random.randrange(9, 22)

    @staticmethod
    def size(struct, seed=None):
        """Size from 4 clusters (minimal value generated by qemu-img) to 10 MB
        """
        random.seed(seed)
        cluster_size = Generators.cluster_size(struct)
        return random.randrange(4*cluster_size, 5*2**21 + 1, cluster_size)

    @staticmethod
    def crypt_method(struct, seed=None):
        """Until encryption is not supported"""
        return 0

class Item(object):
    def __init__(self, offset, value, endianess='B', size=4, v_type='uint'):
        self.offset = offset
        self.endianess = endianess
        self.size = size
        self.v_type = v_type
        self.value = value
        self.fmt = self.endianess + self.v_type + str(self.size*8)

header = OrderedDict([
    ('magic', Item(fixed(0), Generators.magic, v_type='char')),
    ('version', Item(follow(['header', 'magic']), Generators.version)),
    ('backing_file_offset', Item(follow(['header', 'version']),
                                 Generators.backing_file_offset, size=8)),
    ('backing_file_size', Item(follow(['header', 'backing_file_offset']),
                               Generators.backing_file_size)),
    ('cluster_bits', Item(follow(['header', 'backing_file_size']),
                          Generators.cluster_bits)),
    ('size', Item(follow(['header', 'cluster_bits']), Generators.size,
                  size=8)),
    ('crypt_method', Item(follow(['header', 'size']),
                          Generators.crypt_method))
])

qcow2 = {
    'header': header
}

