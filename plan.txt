I've chosen a model-based fuzzer and qcow2 as a target image format.
Rationale for first one can be found below. qcow2 format was selected because
it's the native format of QEMU and it seems easier to get information about it
at first-hand from the format maintainers.

Table of contents:

 - Input data
 - Fuzzer requirements
 - Image formats
 - Effectiveness
 - Glossary
 - Schedule


Input data:
----------

 - new image is generated by qemu-img (if necessary snapshots can be added the same way) and modified by qemu-io (changes in an test image structure necessary to be made before fuzzing)
 - image structure template
 - action vector (optional)
 - ratio (optional)
 - seed (optional)
 - flag indicated if fuzzing values should be taken from the vector of
   predefined ones (optional)

Note:  As far as qemu-img and qemu-io are tested before release, it can be
freely assumed that they generate correct positive output.


Fuzzer requirements:
-------------------

1. Should be able to inject random data
2. Should be able to permutate part of specified data
3. Should accept a seed as an argument (for regression purpose)
4. Should accept a ratio (per cent of bytes randomized) as an argument
   (for regression purpose)
5. Should be able to select a random value from the manually pregenerated
   vector (boundary values, e.g. max/min cluster size)
6. Should accept an image general inner structure as input data, e.g. via
   template file (e.g. header structure, table references, snapshot references,
   etc)
7. Image template file should describe a general structure invariant for all
   test images (image format description)
8. Image structure should not be hardcoded
9. Image template should contain reference rules (not only block+size
   description)
10. Should accept a vector of actions as a parameter (for test reproducing and
   for test case specification, e.g. group of tests for header structure,
   group of test for snapshots, etc)
11. Should be able to interpret the current test image and accurately modify it
   based on an image structure template
12. Vector of actions should be randomly generated from the pool of available
   actions, if it is not specified as an input parameter
13. Pool of actions should be defined automatically based on an image template
14. Seed, ratio and action vector should be logged (for regression purpose)
15. All files related to test result should be collected: logs, crash dumps,
   etc.
16. Should be compatible with python version 2.4-2.7
17. Usage of external libraries should be limited as much as possible.


Image formats:
-------------

Main target image format is qcow2, but support of image templates should provide an ability to add any other image format.


Effectiveness:
-------------

Fuzzer can be controlled via template and action vector; this make the fuzzer
itself invariant to an image format and test logic. It should be able to
perform rather complex and precise tests, that can be specified via action
vector. Otherwise, knowledge about an image structure allows the fuzzer to
generate the pool of all available areas can be fuzzed and randomly select some
of them and so compose its own action vector. Also complexity of a template
defines complexity of the fuzzer, so its functionality can be varied from
simple model-independent fuzzing to smart model-based one.


Glossary:
--------

Action vector is a sequence of structure elements retrieved from an image
format, each of which will be fuzzed for the test image. It's a subset of
elements of the action pool.
Action pool is all available elements of an image structure that generated
automatically from an image template.
Image template is a formal description of an image structure and relations
between image blocks
Test image is an output image of fuzzer defined by the current seed, ratio and
action vector.


Schedule:
--------

1 week - search and evaluation of suitable fuzzing instruments (libraries,
         frameworks, etc)
3 weeks - simple fuzzer that accepts a monolithic image structure, including
          wrapper that generates sample images to be fuzzed.
2 weeks - support of header fuzzing
1.5 weeks - support of first level tables
1 week - support of second level tables
1.5 weeks - testing and optimization (ratio of valid/invalid images, time of
            one test execution, effectiveness of algorithm of selection from
            action pool, etc)

Two weeks are left as a buffer, that can be spent on completion of an
incorrectly estimated task or on implementation of additional features,
e.g. snapshots.
