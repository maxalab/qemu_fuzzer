I've chosen a model-based fuzzer and qcow2 as a target image format.
Rationale for first one can be found below. qcow2 format was selected because it's the native format of QEMU and it seems easier to get information about it at first-hand from the format maintainers.

Table of contents:

 - Input data
 - Fuzzer requirements
 - Image formats
 - Effectiveness
 - Glossary
 - Schedule


Input data:
----------

 - new image is generated by qemu-img (if necessary snapshots can be added the same way) and modified by qemu-io (changes in an test image structure necessary to be made before fuzzing)
 - image structure template
 - action vector (optional)
 - ratio (optional)
 - seed (optional)

Note:  As far as qemu-img and qemu-io are tested before release, it can be
freely assumed that they generate correct positive output.


Fuzzer requirements:
-------------------

1. Should be able to inject random data
2. Should be able to permutate part of specified data
2. Should accept seed as an argument (for regression purpose)
3. Should accept ratio (per cent of bytes randomized) as an argument (for regression purpose)
4. Should accept image general inner structure as input data, e.g. via template file (e.g. header structure, table references, snapshot references, etc)
5. Image template file should describe a general structure invariant for all test images (image format description)
6. Image structure should not be hardcoded
7. Image template should contain reference rules (not only block+size description)
8. Should accept a vector of actions as a parameter (for test reproducing and for test case specification, e.g. group of tests for header structure, group of test for snapshots, etc)
10. Should be able to interpret current test image and accurately modify it based on an image structure template
11. Vector of actions should be randomly generated from the pool of available actions, if it is not specified as an input parameter
12. Pool of actions should be defined automatically based on an image template
13. Seed, ratio and action vector should be logged (for regression purpose)
14. All files related to test result should be collected: logs, crash dumps, etc.


Image formats:
-------------

Main target image format is qcow2, but support of image templates should provide ability to easy add any other image format.


Effectiveness:
-------------

Fuzzer can be controlled via template and action vector; this make the fuzzer itself invariant to an image format and test logic. It should be able to perform rather complex and precise tests, that can be specified via action vector. Otherwise, knowledge about image structure allows the fuzzer to generate the pool of all available areas can be fuzzed and randomly select some of them and so compose its own action vector. Also complexity of a template defines complexity of the fuzzer, so its functionality can be varied from simple model-independent fuzzing to smart model-based one.


Glossary:
--------

Action vector is a sequence of structure elements retrieved from an image format, each of which will be fuzzed for the test image. It's a subset of elements of the action pool.
Action pool is all available elements of an image structure that generated automatically from an image template.
Image template is a formal description of an image structure and relations between image blocks
Test image is an output image of fuzzer defined by current seed, ratio and action vector.


Schedule:
--------

1 week - search and evaluation of suitable fuzzing instruments (libraries, frameworks, etc)
3 weeks - simple fuzzer that accepts a monolithic image structure, including wrapper that generates sample images to be fuzzed.
2 weeks - support of header fuzzing
1.5 weeks - support of first level tables
1 week - support of second level tables
1.5 weeks - testing and optimization (ratio of valid/invalid images, time of one test execution, effectiveness of algorithm of selection from action pool, etc)

Two weeks are left as a buffer, that can be spent on completion of an incorrectly estimated task or on implementation of additional features, e.g. snapshots.

